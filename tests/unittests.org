# -*- coding:utf-8; -*-
#+TITLE: Unit Tests & Examples for Orgtbl Aggregate
Copyright (C) 2013-2026  Thierry Banel

org-aggregate is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

org-aggregate is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

* How to run?
Running all tests should not change anything to this page.

Run this script to complete all the unit tests in a disposable
buffer. When done, the buffer and the original, untouched
~unittests.org~, are compared, stopping at the first difference.

#+begin_src elisp :results none
(delete-other-windows)
(goto-char (point-min))
(org-cycle '(64))
(split-window-right)

;; Make a new buffer and fill it with the content of unittests.org

(let ((f (buffer-file-name)))
  (switch-to-buffer "disposable-unittest.org")
  (erase-buffer)
  (insert-file f))

(org-mode)
(org-cycle '(64))

;; Clean results from prior tests
(save-excursion
  (goto-char (point-min))
  (replace-regexp
   (rx (group
        bol "#+BEGIN" (* not-newline) "\n"
        (* (* (any " \t")) "#+" (* not-newline) "\n"))
       (* "|" (* not-newline) "\n"))
   "\\1\n"))

;; Compute all pull-mode tests
(let ((org-calc-default-modes
       (cons 'calc-float-format (cons '(float 12) org-calc-default-modes))))
  (org-update-all-dblocks))

;; Compute all push-mode tests
(let ((org-calc-default-modes
       (cons 'calc-float-format (cons '(float 12) org-calc-default-modes))))
  (org-table-map-tables
    (lambda ()
      (when (save-excursion
	      (forward-line -1)
	      (looking-at-p (rx (or "#+begin" "#+orgtbl"))))
	(orgtbl-send-table 'maybe)))))

;; Compare the disposable buffer with the reference unittests.org
(goto-char (point-min))
(compare-windows nil)
  #+end_src

* Test PUSH
Push = source table drives computation of aggregated tables.
Run by typing C-c C-c on the first pipe of the source table.

** Source table
No need to name it.

#+ORGTBL: SEND aggtable1 orgtbl-to-aggregated-table :cols "sum($3) $2 sum($4) mean($5) $3*$3 min($5) max($5)"
#+ORGTBL: SEND aggtable2 orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)"
#+ORGTBL: SEND aggtable3 orgtbl-to-aggregated-table :cols "p count() sum($4) mean(z) sum(z*z) (x) min(y) max(y)"
#+ORGTBL: SEND aggtable4 orgtbl-to-aggregated-table :cols "count() mean(x) mean(y) mean(z) meane(z) median(z)" :cond (not (equal f ""))
#+ORGTBL: SEND aggtable5 orgtbl-to-aggregated-table :cols "count() mean(x) mean(y) mean(z) meane(z) median(z) hline"
#+ORGTBL: SEND aggtable6 orgtbl-to-aggregated-table :cols "q prod(z) sdev(z) pvar(z) psdev(z)"
#+ORGTBL: SEND aggtable7 orgtbl-to-aggregated-table :cols "q prod(z) cov(x,y) corr(z,z)"
#+ORGTBL: SEND aggtable8 orgtbl-to-aggregated-table :cols "hline min(d) max(d) mean(d)"
#+ORGTBL: SEND aggtable9 orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)" :cond (equal hline 2)
#+ORGTBL: SEND aggtablea orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)" :cond (equal q "b")
| p | q |   x |    y | z | f | d                      |
|---+---+-----+------+---+---+------------------------|
| 1 | b |  12 |    8 | 9 | 0 | [2013-12-22 sun 09:01] |
| 3 | b |  12 |    8 | 9 | 0 | [2013-11-23 sat 13:04] |
| 1 | a |   3 |    2 | 4 | 0 | [2011-09-24 sat 13:54] |
| 2 | a |   3 |    2 | 2 |   | [2013-09-25 wed 03:54] |
| 3 | a |   3 |    2 | 1 |   | [2014-02-26 wed 16:11] |
| 3 | a |   5 |    4 | 2 |   | [2014-01-18 sat 03:51] |
| 1 | a | 5.1 |    2 | 8 | 1 | [2013-12-25 wed 00:00] |
|---+---+-----+------+---+---+------------------------|
| 2 | b |   9 |    8 | 5 |   | [2012-12-25 tue 00:00] |
| 3 | b |   9 |    8 | 1 |   | [2014-01-18 sat 23:22] |
| 4 | a |   a |    a | 8 |   | [2014-08-02 sat 23:22] |
| 5 | a |   a | 10*a | 4 |   | [2015-09-14 mon 13:07] |
|---+---+-----+------+---+---+------------------------|
| 4 | b |   b |    b | 6 | 1 | [2015-10-02 fri 17:42] |
| 5 | b | b+3 |  b*b | 8 | 1 | [2016-01-28 thu 15:06] |

** Resulting tables

#+BEGIN RECEIVE ORGTBL aggtable1
| sum($3)    | $2 | sum($4)      |      mean($5) | $3*$3             | min($5) | max($5) |
|------------+----+--------------+---------------+-------------------+---------+---------|
| 2 b + 45   | b  | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |       1 |       9 |
| 2 a + 19.1 | a  | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |       1 |       8 |
#+END RECEIVE ORGTBL aggtable1

#+BEGIN RECEIVE ORGTBL aggtable2
| sum(x)     | q | sum(y)       |       mean(z) | x*x               | min(z) | max(z) |
|------------+---+--------------+---------------+-------------------+--------+--------|
| 2 b + 45   | b | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |      1 |      9 |
| 2 a + 19.1 | a | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |      1 |      8 |
#+END RECEIVE ORGTBL aggtable2

#+BEGIN RECEIVE ORGTBL aggtable3
| p | count() |    sum($4) | mean(z) | sum(z*z) | (x)           |         min(y) |         max(y) |
|---+---------+------------+---------+----------+---------------+----------------+----------------|
| 1 |       3 |         12 |       7 |      161 | [12, 3, 5.1]  |              2 |              8 |
| 3 |       4 |         22 |    3.25 |       87 | [12, 3, 5, 9] |              2 |              8 |
| 2 |       2 |         10 |     3.5 |       29 | [3, 9]        |              2 |              8 |
| 4 |       2 |      a + b |       7 |      100 | [a, b]        |      min(a, b) |      max(a, b) |
| 5 |       2 | 10 a + b^2 |       6 |       80 | [a, b + 3]    | min(10 a, b^2) | max(10 a, b^2) |
#+END RECEIVE ORGTBL aggtable3

#+BEGIN RECEIVE ORGTBL aggtable4
| count() | mean(x)                 | mean(y)                         |       mean(z) | meane(z)                         | median(z) |
|---------+-------------------------+---------------------------------+---------------+----------------------------------+-----------|
|       6 | 0.333333333333 b + 5.85 | b / 6 + b^2 / 6 + 3.33333333333 | 7.33333333333 | 7.33333333333 +/- 0.802772971919 |         8 |
#+END RECEIVE ORGTBL aggtable4

#+BEGIN RECEIVE ORGTBL aggtable5
| count() | mean(x)       | mean(y)         | mean(z) | meane(z)              | median(z) | hline |
|---------+---------------+-----------------+---------+-----------------------+-----------+-------|
|       7 | 6.15714285714 | 4               |       5 | 5 +/- 1.34518541827   |         4 |     0 |
|       4 | 0.5 a + 4.5   | 2.75 a + 4      |     4.5 | 4.5 +/- 1.44337567297 |       4.5 |     1 |
|       2 | b + 1.5       | b / 2 + b^2 / 2 |       7 | 7 +/- 1               |         7 |     2 |
#+END RECEIVE ORGTBL aggtable5

#+BEGIN RECEIVE ORGTBL aggtable6
| q | prod(z) |       sdev(z) |       pvar(z) |      psdev(z) |
|---+---------+---------------+---------------+---------------|
| b |   19440 | 3.07679486912 | 7.88888888889 | 2.80871659106 |
| a |    4096 | 2.85356919364 | 6.97959183673 | 2.64189171556 |
#+END RECEIVE ORGTBL aggtable6

#+BEGIN RECEIVE ORGTBL aggtable7
| q | prod(z) | cov(x,y)                                                         | corr(z,z) |
|---+---------+------------------------------------------------------------------+-----------|
| b |   19440 | 0.133333333333 b^3 - 3.63333333333 b - 0.766666666667 b^2 + 19.2 |        1. |
| a |    4096 | 1.30952380953 a^2 - 5.57380952381 a + 2.5761904762               |        1. |
#+END RECEIVE ORGTBL aggtable7

#+BEGIN RECEIVE ORGTBL aggtable8
| hline | min(d)                 | max(d)                 |                     mean(d) |
|-------+------------------------+------------------------+-----------------------------|
|     0 | <2011-09-24 Sat 13:54> | <2014-02-26 Wed 16:11> | <14089-07-11 Mon 11:55> / 7 |
|     1 | <2012-12-25 Tue 00:00> | <2015-09-14 Mon 13:07> |               735354.373438 |
|     2 | <2015-10-02 Fri 17:42> | <2016-01-28 Thu 15:06> |               735932.683334 |
#+END RECEIVE ORGTBL aggtable8

#+BEGIN RECEIVE ORGTBL aggtable9
| sum(x)  | q | sum(y)  | mean(z) | x*x             | min(z) | max(z) |
|---------+---+---------+---------+-----------------+--------+--------|
| 2 b + 3 | b | b + b^2 |       7 | 2 b^2 + 6 b + 9 |      6 |      8 |
#+END RECEIVE ORGTBL aggtable9

#+BEGIN RECEIVE ORGTBL aggtablea
| sum(x)   | q | sum(y)       |       mean(z) | x*x               | min(z) | max(z) |
|----------+---+--------------+---------------+-------------------+--------+--------|
| 2 b + 45 | b | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |      1 |      9 |
#+END RECEIVE ORGTBL aggtablea

* Test PULL
Pull = aggregated table knows how to compute itself,
       source table is unaware of the aggregation.

** Source table
Not changed in any way by the aggregate process.
(Note: non-ascii characters are used as column names)

#+TBLNAME: pulledtable
| pé | qû |  xà |   yÿ | zö | déf |
|----+----+-----+------+----+-----|
|  1 | b  |  12 |    8 |  9 |     |
|  3 | b  |  12 |    8 |  9 |     |
|  1 | a  |   3 |    2 |  4 |   1 |
|  2 | a  |   3 |    2 |  2 |     |
|  3 | a  |   3 |    2 |  1 |   1 |
|  3 | a  |   5 |    4 |  2 |   1 |
|  1 | a  | 5.1 |    2 |  8 |   1 |
|  2 | b  |   9 |    8 |  5 |     |
|  3 | b  |   9 |    8 |  1 |     |
|  4 | a  |   a |    a |  8 |     |
|  5 | a  |   a | 10*a |  4 |   1 |
|  4 | b  |   b |    b |  6 |   1 |
|  5 | b  | b+3 |  b*b |  8 |     |

** Resulting tables
Type C-c C-c within each to refresh

Note the =:formula= parameter to add a new column after the aggregation has been computed.

#+BEGIN: aggregate :table pulledtable :cols ("qû" "mean(zö)") :formula "$3=$2*100"
| qû |      mean(zö) |           |
|----+---------------+-----------|
| b  | 6.33333333333 | 633.33333 |
| a  | 4.14285714286 | 414.28571 |
#+TBLFM: $3=$2*100
#+END

Note the additional =$8= column automatically computed after the aggregation

#+BEGIN: aggregate :table pulledtable :cols "sum(xà) qû sum(yÿ) mean(zö) xà*xà min(zö) max(zö)"
| sum(xà)    | qû | sum(yÿ)      |      mean(zö) | xà*xà             | min(zö) | max(zö) |     |
|------------+----+--------------+---------------+-------------------+---------+---------+-----|
| 2 b + 45   | b  | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |       1 |       9 |   5 |
| 2 a + 19.1 | a  | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |       1 |       8 | 4.5 |
#+TBLFM: $8=($6+$7)/2
#+END

#+BEGIN: aggregate :table pulledtable :cols "pé count() sum($4) mean(zö) sum(zö*zö) (xà) min(yÿ) max(yÿ)"
#+caption: named_table
#+attr_latex: :environment longtable :width \linewidth
| pé | count() |    sum($4) | mean(zö) | sum(zö*zö) | (xà)          |        min(yÿ) |        max(yÿ) |
|----+---------+------------+----------+------------+---------------+----------------+----------------|
|  1 |       3 |         12 |        7 |        161 | [12, 3, 5.1]  |              2 |              8 |
|  3 |       4 |         22 |     3.25 |         87 | [12, 3, 5, 9] |              2 |              8 |
|  2 |       2 |         10 |      3.5 |         29 | [3, 9]        |              2 |              8 |
|  4 |       2 |      a + b |        7 |        100 | [a, b]        |      min(a, b) |      max(a, b) |
|  5 |       2 | 10 a + b^2 |        6 |         80 | [a, b + 3]    | min(10 a, b^2) | max(10 a, b^2) |
#+END

#+BEGIN: aggregate :table pulledtable :cols "count() mean(xà) mean(yÿ) mean(zö)"
| count() | mean(xà)                                            | mean(yÿ)                                             |      mean(zö) |
|---------+-----------------------------------------------------+------------------------------------------------------+---------------|
|      13 | 0.153846153846 a + 0.153846153846 b + 4.93076923077 | 0.846153846154 a + b / 13 + b^2 / 13 + 3.38461538462 | 5.15384615385 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "pé count() mean(zö) meane(zö) gmean(zö) hmean(zö) median(zö)"
| pé | count() | mean(zö) | meane(zö)              |     gmean(zö) |     hmean(zö) | median(zö) |
|----+---------+----------+------------------------+---------------+---------------+------------|
|  1 |       3 |        7 | 7 +/- 1.52752523165    | 6.60385449779 | 6.17142857143 |          8 |
|  3 |       4 |     3.25 | 3.25 +/- 1.93110503771 | 2.05976714391 | 1.53191489362 |        1.5 |
|  2 |       2 |      3.5 | 3.5 +/- 1.5            | 3.16227766017 | 2.85714285714 |        3.5 |
|  4 |       2 |        7 | 7 +/- 1                | 6.92820323028 | 6.85714285714 |          7 |
|  5 |       2 |        6 | 6 +/- 2                | 5.65685424949 | 5.33333333333 |          6 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "qû count() prod(zö) sdev(zö) pvar(zö) psdev(zö)"
| qû | count() | prod(zö) |      sdev(zö) |      pvar(zö) |     psdev(zö) |
|----+---------+----------+---------------+---------------+---------------|
| b  |       6 |    19440 | 3.07679486912 | 7.88888888889 | 2.80871659106 |
| a  |       7 |     4096 | 2.85356919364 | 6.97959183673 | 2.64189171556 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "qû count() cov(zö,xà) pcov(zö,zö) corr(zö,zö)"
| qû | count() | cov(zö,xà)                       |   pcov(zö,zö) | corr(zö,zö) |
|----+---------+----------------------------------+---------------+-------------|
| b  |       6 | 0.266666666666 b + 1.8           | 7.88888888889 |          1. |
| a  |       7 | 0.619047619047 a - 1.22142857142 | 6.97959183673 |          1. |
#+END

* Test :cond PUSH

** Source table
Only the second group (5 rows) is considered with the test =hline=1=.

#+ORGTBL: SEND aggtable15 orgtbl-to-aggregated-table :cond (equal hline 1) :cols "count() q mean(x) mean(y) mean(z) hline"
| p | q |   x |    y | z |
|---+---+-----+------+---|
| 1 | b |  12 |    8 | 9 |
| 3 | b |  12 |    8 | 9 |
| 1 | a |   3 |    2 | 4 |
| 2 | a |   3 |    2 | 2 |
| 3 | a |   3 |    2 | 1 |
| 3 | a |   5 |    4 | 2 |
| 1 | a | 5.1 |    2 | 8 |
|---+---+-----+------+---|
| 2 | b |   9 |    8 | 5 |
| 3 | b |   9 |    8 | 1 |
| 4 | a |   a |    a | 8 |
| 5 | a |   a | 10*a | 4 |
| 4 | b |   b |    b | 6 |
|---+---+-----+------+---|
| 5 | b | b+3 |  b*b | 8 |

** Aggregated table

#+BEGIN RECEIVE ORGTBL aggtable15
| count() | q | mean(x)   | mean(y)               | mean(z) | hline |
|---------+---+-----------+-----------------------+---------+-------|
|       3 | b | b / 3 + 6 | b / 3 + 5.33333333333 |       4 |     1 |
|       2 | a | a         | 5.5 a                 |       6 |     1 |
#+END RECEIVE ORGTBL aggtable15

* Test :cond PULL
The =:cond= parameter takes a lisp expression
to filter-out resulting rows.

** Resulting tables
Only consider rows for which column q have the value "b"

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö)" :cond (equal qû "b")
| qû | count() |      mean(zö) |
|----+---------+---------------|
| b  |       6 | 6.33333333333 |
#+END

Only consider rows for which column =p= is greater than =3=.
Note the =string-to-number= call, because cells always contain strings.

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö)" :cond (>= (string-to-number pé) 3)
| qû | count() | mean(zö) |
|----+---------+----------|
| b  |       4 |        6 |
| a  |       4 |     3.75 |
#+END

Only consider rows for which the =def= column is not blank.

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö) déf" :cond (not (equal déf ""))
| qû | count() | mean(zö) | déf |
|----+---------+----------+-----|
| a  |       5 |      3.8 |   1 |
| b  |       1 |        6 |   1 |
#+END

* Test correlation
Are two columns correlated ?

** Source table
Contains columns correlated with some noise.
: y = 10* + noise             (x y are highly correlated)
: z = pure noise              (x z are not correlated)
: t = pure noise              (z t are not correlated)
: m = 10*x in reverse order   (x m are negative correlated)

#+TBLNAME: correlated
| tag   |  x |       y |     z |     t |   m |
|-------+----+---------+-------+-------+-----|
| small |  1 |  10.414 | 78.30 |  1.70 | 120 |
| small |  2 |  20.616 | 48.20 | 80.40 | 110 |
| small |  3 |  30.210 | 93.50 | 25.10 | 100 |
| small |  4 |  41.692 | 85.90 | 16.30 |  90 |
| small |  5 |  50.576 | 11.70 | 37.00 |  80 |
| large |  6 |  60.026 | 46.60 |  6.00 |  70 |
| large |  7 |  71.236 |  3.30 | 35.70 |  60 |
| large |  8 |  81.204 | 78.80 | 46.30 |  50 |
| large |  9 |  90.862 | 89.60 | 98.40 |  40 |
| large | 10 | 101.240 |  0.60 |  8.80 |  30 |
| large | 11 | 111.924 | 32.40 | 63.70 |  20 |
| large | 12 | 120.490 | 35.50 | 98.20 |  10 |

The following line was appended to the table to generate the random noise.
It is thrown away to avoid recomputing new noise, and thus invalidating the test.
: #+TBLFM: $3=$2*10+random(1000)/500;%.3f::$4=random(1000)/10;%.2f::$5=random(1000)/10;%.2f

** Resulting table
Type C-c C-c within resulting table to refresh.

#+BEGIN: aggregate :table correlated :cols "tag corr(x,y) corr(x,z) corr(x,m) corr(z,t)"
| tag   |      corr(x,y) |       corr(x,z) | corr(x,m) |      corr(z,t) |
|-------+----------------+-----------------+-----------+----------------|
| small | 0.999449791325 | -0.448296141593 |        -1 | -0.49786310458 |
| large | 0.999657841285 | -0.120566390616 |        -1 | 0.486014333463 |
#+END

* Test without headers
What if the source table does not have headers?
Then columns should be named =$1=, =$2=, =$3= and so on.

** Source table

#+TBLNAME: noheader
| 0 | z |   t |    x | y |
| 1 | b |  12 |    8 | 9 |
| 3 | b |  12 |    8 | 9 |
| 1 | a |   3 |    2 | 4 |
| 2 | a |   3 |    2 | 2 |
| 3 | a |   3 |    2 | 1 |
| 3 | a |   5 |    4 | 2 |
| 1 | a | 5.1 |    2 | 8 |
| 2 | b |   9 |    8 | 5 |
| 3 | b |   9 |    8 | 1 |
| 4 | a |   a |    a | 8 |
| 5 | a |   a | 10*a | 4 |
| 4 | b |   b |    b | 6 |
| 5 | b | b+3 |  b*b | 8 |

** Aggregated table

#+BEGIN: aggregate :table noheader :cols "hline $1 mean($3) sum($4)"
| hline | $1 | mean($3)            | sum($4)    |
|-------+----+---------------------+------------|
|     0 |  0 | t                   | x          |
|     0 |  1 | 6.7                 | 12         |
|     0 |  3 | 7.25                | 22         |
|     0 |  2 | 6                   | 10         |
|     0 |  4 | a / 2 + b / 2       | a + b      |
|     0 |  5 | a / 2 + b / 2 + 1.5 | 10 a + b^2 |
#+END

* Test hline grouping
Horizontal lines naturally create groups withing the source table.
Those groups can be accessed through the =hline= virtual column.

** Source table
It contains four groups separated by horizontal lines.

#+TBLNAME: hlinetable
| p | q |   x |    y | z | f |
|---+---+-----+------+---+---|
| 1 | b |  12 |    8 | 9 | 0 |
| 3 | b |  12 |    8 | 9 | 0 |
| 1 | a |   3 |    2 | 4 | 0 |
| 2 | a |   3 |    2 | 2 | 0 |
| 3 | a |   3 |    2 | 1 | 0 |
|---+---+-----+------+---+---|
| 3 | a |   5 |    4 | 2 | 1 |
| 1 | a | 5.1 |    2 | 8 | 1 |
|---+---+-----+------+---+---|
| 2 | b |   9 |    8 | 5 | 1 |
| 3 | b |   9 |    8 | 1 | 1 |
| 4 | a |   a |    a | 8 | 1 |
|---+---+-----+------+---+---|
| 5 | a |   a | 10*a | 4 | 1 |
| 4 | b |   b |    b | 6 | 1 |
| 5 | b | b+3 |  b*b | 8 | 1 |

** Aggregated table
The =hline= column groups data

#+BEGIN: aggregate :table hlinetable :cols "q hline vcount()" :cond (equal f "1")
| q | hline | vcount() |
|---+-------+----------|
| a |     1 |        2 |
| b |     2 |        2 |
| a |     2 |        1 |
| a |     3 |        1 |
| b |     3 |        2 |
#+END

* Test @# row numbering

are a's & b's near the beginning or the end of the input table?
#+BEGIN: aggregate :table "hlinetable" :cols "q vmean(@#)"
| q |     vmean(@#) |
|---+---------------|
| b | 9.16666666667 |
| a | 7.57142857143 |
#+END:

p & q columns in reverse order
#+BEGIN: aggregate :table "hlinetable" :cols "p q hline @#;^N2;<>"
| p | q | hline |
|---+---+-------|
| 5 | b |     3 |
| 4 | b |     3 |
| 5 | a |     3 |
| 4 | a |     2 |
| 3 | b |     2 |
| 2 | b |     2 |
| 1 | a |     1 |
| 3 | a |     1 |
| 3 | a |     0 |
| 2 | a |     0 |
| 1 | a |     0 |
| 3 | b |     0 |
| 1 | b |     0 |
#+END:

* Test dates [YYYY-MM-DD day. HH:MM] style
Some (limited) handling of dates is available.

** Source table
#+tblname: datetable
| n | d                       |
|---+-------------------------|
| 1 | [2013-12-22 dim. 09:01] |
| 2 | [2013-11-23 sam. 13:04] |
| 3 | [2011-09-24 sam. 13:54] |
| 4 | [2013-09-25 mer. 03:54] |
| 5 | [2014-02-26 mer. 16:11] |
| 6 | [2014-01-18 sam. 03:51] |
| 7 | [2013-12-25 mer. 00:00] |
| 8 | [2012-12-25 mar. 00:00] |

** Aggregated table

#+BEGIN: aggregate :table datetable :cols "min(d) max(d) min(n) max(n) mean(d)"
| min(d)                 | max(d)                 | min(n) | max(n) |       mean(d) |
|------------------------+------------------------+--------+--------+---------------|
| <2011-09-24 Sat 13:54> | <2014-02-26 Wed 16:11> |      1 |      8 | 735073.937066 |
#+END

* Test durations HH:MM:SS style

** Source table
#+name: some_durations
|      dur |
|----------|
| 07:45:30 |
|    13:55 |
|    17:12 |

#+name: some_durations_in_different_formats
|      dur |
|----------|
| 01:30:01 |
|  1:30:02 |
|    01:30 |
|     1:30 |
|   100:30 |

** Aggregated table

Test T, U, t formatters

#+BEGIN: aggregate :table "some_durations" :cols "vmean(dur) vmean(dur);T vmean(dur);t vmean(dur);U"
| vmean(dur) | vmean(dur) | vmean(dur) | vmean(dur) |
|------------+------------+------------+------------|
|      46650 |   12:57:30 |      12.96 |      12:57 |
#+END:

#+BEGIN: aggregate :table "some_durations_in_different_formats" :cols "vsum(dur);T"
| vsum(dur) |
|-----------|
| 106:30:03 |
#+END

* Test durations HH@ MM' SS" style

#+name: calc_durations
| dur        |
|------------|
| 07@ 45' 30 |
| 13@ 55'    |
| 17@ 12'    |

#+BEGIN: aggregate :table "calc_durations" :cols "vmean(dur)"
| vmean(dur)   |
|--------------|
| 12@ 57' 30." |
#+END:

* Test symbolic
The Emacs Calc symbolic calculator is used by the aggregate package.
Therefore, symbolic calculations are available.

** Source table
Contains the variables =x= and =a=, which are not numeric.

#+TBLNAME: symtable
| Day       | Color |  Level | Quantity |
|-----------+-------+--------+----------|
| Monday    | Red   |   30+x |     11+a |
| Monday    | Blue  | 25+3*x |        3 |
| Thuesday  | Red   | 51+2*x |       12 |
| Thuesday  | Red   |   45-x |       15 |
| Thuesday  | Blue  |     33 |       18 |
| Wednesday | Red   |     27 |       23 |
| Wednesday | Blue  |   12+x |       16 |
| Wednesday | Blue  |     15 |   15-6*a |
| Turdsday  | Red   |     39 |   24-5*a |
| Turdsday  | Red   |     41 |       29 |
| Turdsday  | Red   |   49+x |   30+9*a |
| Friday    | Blue  |      7 |      5+a |
| Friday    | Blue  |      6 |        8 |
| Friday    | Blue  |     11 |        9 |

** Aggregated table
Result is variabilized with =x= and =a=.

#+BEGIN: aggregate :table "symtable" :cols "Day mean(Level) sum(Quantity)"
| Day       | mean(Level) | sum(Quantity) |
|-----------+-------------+---------------|
| Monday    | 2 x + 27.5  | a + 14        |
| Thuesday  | x / 3 + 43  | 45            |
| Wednesday | x / 3 + 18  | 54 - 6 a      |
| Turdsday  | x / 3 + 43. | 4 a + 83      |
| Friday    | 8           | a + 22        |
#+END

* Test zero output
The following test produces sums which happen to be zero, either
because input is empty, or by chance (1-1 = 0).
Zeros are no longer translated to empty cells.

#+TBLNAME: resultzero
| Item | Value |
|------+-------|
| a2   |     1 |
| a2   |     1 |
| a0   |    -1 |
| a0   |     1 |
| b2   |     2 |
| b2   |       |
| b0   |     0 |
| b0   |       |
| c    |       |
| c    |       |

#+BEGIN: aggregate :table resultzero :cols "Item vsum(Value) vmean(Value)"
| Item | vsum(Value) | vmean(Value) |
|------+-------------+--------------|
| a2   |           2 |            1 |
| a0   |           0 |            0 |
| b2   |           2 |            2 |
| b0   |           0 |            0 |
| c    |           0 |    vmean([]) |
#+END

* Test empty inputs
Empty input cells are most often ignored.
- This makes no difference for =sum= and =count=.
- For =prod=, empty input do not result in zero.
- For =mean=, only non-empty cells participate
  (if empty cells were zero, they would count in the division).
- For =min= and =max=, a possibly empty list of values is possible,
  resulting in =inf= or =-inf=

Some aggregation functions operate on two columns.
In this case, a pair of empty cells is ignored.
But a pair of an empty and a non-empty cell is
added to the aggregation, by replacing the missing
value with zero.

#+tblname: emptyinput
| T                |  Q |   R |
|------------------+----+-----|
| no-blank         |  1 |  10 |
| no-blank         |  2 |  20 |
| no-blank         |  3 |  30 |
| 1-left-blank     |  4 |  40 |
| 1-left-blank     |    |  50 |
| 1-left-blank     |  6 |  60 |
| 1-left-blank     |  7 |  70 |
| all-blank        |    |     |
| all-blank        |    |     |
| all-blank        |    |     |
| 2-left-blank     | 11 | 110 |
| 2-left-blank     | 12 | 120 |
| 2-left-blank     | 13 | 130 |
| 2-left-blank     | 14 | 140 |
| 1-dual-blank     | 15 | 150 |
| 1-dual-blank     |    |     |
| 1-dual-blank     | 17 | 170 |
| single-non-blank | 18 | 180 |
| single-non-blank |    |     |
| single-non-blank |    |     |

#+BEGIN: aggregate :table "emptyinput" :cols "T sum(Q) prod(Q) (Q) min(Q) max(Q)"
| T                | sum(Q) | prod(Q) | (Q)              | min(Q) | max(Q) |
|------------------+--------+---------+------------------+--------+--------|
| no-blank         |      6 |       6 | [1, 2, 3]        |      1 |      3 |
| 1-left-blank     |     17 |     168 | [4, 6, 7]        |      4 |      7 |
| all-blank        |      0 |       1 | []               |    inf |   -inf |
| 2-left-blank     |     50 |   24024 | [11, 12, 13, 14] |     11 |     14 |
| 1-dual-blank     |     32 |     255 | [15, 17]         |     15 |     17 |
| single-non-blank |     18 |      18 | [18]             |     18 |     18 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T mean(Q) meane(Q) gmean(Q) hmean(Q)"
| T                |       mean(Q) | meane(Q)                         |      gmean(Q) |      hmean(Q) |
|------------------+---------------+----------------------------------+---------------+---------------|
| no-blank         |             2 | 2 +/- 0.577350269189             | 1.81712059283 | 1.63636363636 |
| 1-left-blank     | 5.66666666667 | 5.66666666667 +/- 0.881917103688 | 5.51784835276 | 5.36170212766 |
| all-blank        |     vmean([]) | vmeane([])                       |    vgmean([]) |    vhmean([]) |
| 2-left-blank     |          12.5 | 12.5 +/- 0.645497224368          | 12.4497700445 |  12.399483871 |
| 1-dual-blank     |            16 | 16 +/- 1                         | 15.9687194227 |       15.9375 |
| single-non-blank |            18 | vmeane([18])                     |            18 |           18. |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T min(Q) max(Q)"
| T                | min(Q) | max(Q) |
|------------------+--------+--------|
| no-blank         |      1 |      3 |
| 1-left-blank     |      4 |      7 |
| all-blank        |    inf |   -inf |
| 2-left-blank     |     11 |     14 |
| 1-dual-blank     |     15 |     17 |
| single-non-blank |     18 |     18 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T pvar(Q) sdev(Q) psdev(Q)"
| T                |        pvar(Q) |       sdev(Q) |       psdev(Q) |
|------------------+----------------+---------------+----------------|
| no-blank         | 0.666666666667 |             1 | 0.816496580928 |
| 1-left-blank     |  1.55555555556 | 1.52752523165 |  1.24721912893 |
| all-blank        |      vpvar([]) |     vsdev([]) |     vpsdev([]) |
| 2-left-blank     |           1.25 | 1.29099444874 |  1.11803398875 |
| 1-dual-blank     |              1 | 1.41421356237 |              1 |
| single-non-blank |              0 |   vsdev([18]) |              0 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T corr(Q,R);EN cov(Q,R);EN pcov(Q,R);EN"
| T                |                   corr(Q,R) |      cov(Q,R) |     pcov(Q,R) |
|------------------+-----------------------------+---------------+---------------|
| no-blank         |                           1 |            10 | 6.66666666667 |
| 1-left-blank     |              0.625543242171 |           25. |         18.75 |
| all-blank        | vcorr([0, 0, 0], [0, 0, 0]) |             0 |             0 |
| 2-left-blank     |                          1. | 16.6666666667 |          12.5 |
| 1-dual-blank     |                          1. | 863.333333333 | 575.555555556 |
| single-non-blank |                           1 |          1080 |           720 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T count() (Q) (R)"
| T                | count() | (Q)              | (R)                  |
|------------------+---------+------------------+----------------------|
| no-blank         |       3 | [1, 2, 3]        | [10, 20, 30]         |
| 1-left-blank     |       4 | [4, 6, 7]        | [40, 50, 60, 70]     |
| all-blank        |       3 | []               | []                   |
| 2-left-blank     |       4 | [11, 12, 13, 14] | [110, 120, 130, 140] |
| 1-dual-blank     |       3 | [15, 17]         | [150, 170]           |
| single-non-blank |       3 | [18]             | [180]                |
#+END:

* Test empty and non-numeric

#+tblname: nonnumeric
|  X |
|----|
|  1 |
|  2 |
| aa |
|    |
|  4 |

#+BEGIN: aggregate :table "nonnumeric" :cols "(X) (X);E (X);N (X);EN"
| (X)           | (X)                | (X)          | (X)             |
|---------------+--------------------+--------------+-----------------|
| [1, 2, aa, 4] | [1, 2, aa, nan, 4] | [1, 2, 0, 4] | [1, 2, 0, 0, 4] |
#+END:

#+BEGIN: aggregate :table "nonnumeric" :cols "mean(X) mean(X);E mean(X);N mean(X);EN"
| mean(X)       | mean(X) | mean(X) | mean(X) |
|---------------+---------+---------+---------|
| aa / 4 + 1.75 |     nan |    1.75 |     1.4 |
#+END:

Comparison with the spreadsheet:

| 1                  |                 1 |
| 2                  |                 2 |
| aa                 |                aa |
|                    |                   |
| 4                  |                 4 |
|--------------------+-------------------|
| [1, 2, aa, 4]      | 0.75 + aa / 4 + 1 |
| [1, 2, aa, nan, 4] |               nan |
| [1, 2, 0, 4]       |              1.75 |
| [1, 2, 0, 0, 4]    |               1.4 |
#+TBLFM: @6$1=@1..@5 :: @7$1=@1..@5;E :: @8$1=@1..@5;N :: @9$1=@1..@5;EN :: @6$2=vmean(@1..@5) :: @7$2=vmean(@1..@5);E :: @8$2=vmean(@1..@5);N :: @9$2=vmean(@1..@5);EN

* Test input errors

#+tblname: inputerrors
| A |  Q |     R |         Z | D            |
|---+----+-------+-----------+--------------|
| a |  3 |    10 | 2.3025851 | [2014-11-05] |
| a | 4+ |    20 | 2.9957323 | [2014-11-21] |
| b |  t | (88*) |    #ERROR | [2014-12-07] |
| b |  1 |    41 | 3.7135721 | [2014-12-23] |
| b |  2 |   111 | 4.7095302 | [2015-01-08] |
| c |  8 |   z ' |    #ERROR |              |
| c | 4= |     4 | 1.3862944 |              |
#+TBLFM: $4=log($3)

#+BEGIN: aggregate :table "inputerrors" :cols "A sum(Q) sum(R)"
| A | sum(Q)                             | sum(R)                               |
|---+------------------------------------+--------------------------------------|
| a | error(2, '"Expected a number") + 3 | 30                                   |
| b | t + 3                              | error(4, '"Expected a number") + 152 |
| c | error(2, '"Expected a number") + 8 | error(2, '"Syntax error") + 4        |
#+END:

#+BEGIN: aggregate :table "inputerrors" :cols "A (Q) (R)"
| A | (Q)                                 | (R)                                       |
|---+-------------------------------------+-------------------------------------------|
| a | [3, error(2, '"Expected a number")] | [10, 20]                                  |
| b | [t, 1, 2]                           | [error(4, '"Expected a number"), 41, 111] |
| c | [8, error(2, '"Expected a number")] | [error(2, '"Syntax error"), 4]            |
#+END:

* Test modifiers

Note the blank line between tblname and the actual table

#+tblname: bigprec

| A  | Q     |                   N |
|----+-------+---------------------|
| a  | 12    |                  20 |
| a  | t+1   |   3.000000000000007 |
| bb | 77    |                   4 |
| bb | 2*t   | 5.12345678987654321 |
| bb | 2*t+1 |                   6 |

#+BEGIN: aggregate :table "bigprec" :cols "A sum(Q) mean(Q);FS (Q)"
| A  | sum(Q)   | mean(Q)      | (Q)                |
|----+----------+--------------+--------------------|
| a  | t + 13   | t / 2 + 13:2 | [12, t + 1]        |
| bb | 4 t + 78 | 4:3 t + 26   | [77, 2 t, 2 t + 1] |
#+END:

#+BEGIN: aggregate :table "bigprec" :cols "A sum(N);p20f18 sum(N);%.5f mean(N);f15 (N);f3"
| A  |                sum(N) |   sum(N) |            mean(N) | (N)           |
|----+-----------------------+----------+--------------------+---------------|
| a  | 23.000000000000007000 | 23.00000 | 11.500000000000000 | [20, 3.000]   |
| bb | 15.123456789876543210 | 15.12346 |  5.041152263290000 | [4, 5.123, 6] |
#+END:
* Test chaining

Result of an aggregation can be further processed, for example with another aggregation.

** chaining 3 aggregations
Note: header is 2 lines tall

#+TBLNAME: amx
| A  | M  |  X |
| ~a | ~m | ~x |
|----+----+----|
| a  | m  |  1 |
| a  | p  |  2 |
| a  | m  |  3 |
|----+----+----|
| b  | p  |  4 |
| b  | m  |  5 |
| b  | p  |  6 |
| b  | m  |  7 |

#+TBLNAME: amsx
#+BEGIN: aggregate :table "amx" :cols "A M sum(X)"
| A  | M  | SX |
| ~a | ~m | ~x |
|----+----+----|
| a  | m  |  4 |
| a  | p  |  2 |
| b  | p  | 10 |
| b  | m  | 12 |
#+TBLFM: @1$3=SX
#+END:

#+TBLNAME: asx
#+BEGIN: aggregate :table "amsx" :cols "A sum(SX)"
#+caption: named_table
| A  | SSX |
| ~a |  ~x |
|----+-----|
| a  |   6 |
| b  |  22 |
#+TBLFM: @1$2=SSX
#+END:

#+BEGIN: aggregate :table "asx" :cols "sum(SSX)"
| sum(SSX) |
| ~x       |
|----------|
| 28       |
#+END:

** chaining 2 transpositions

#+TBLNAME: tamx
#+BEGIN: transpose :table "amx"
| A | ~a |   | a | a | a |   | b | b | b | b |
| M | ~m |   | m | p | m |   | p | m | p | m |
| X | ~x |   | 1 | 2 | 3 |   | 4 | 5 | 6 | 7 |
#+END:

#+BEGIN: transpose :table "tamx"
| A  | M  |  X |
| ~a | ~m | ~x |
|----+----+----|
| a  | m  |  1 |
| a  | p  |  2 |
| a  | m  |  3 |
|----+----+----|
| b  | p  |  4 |
| b  | m  |  5 |
| b  | p  |  6 |
| b  | m  |  7 |
#+END:

The double transposition is identical to the original "amx" table,
including horizontal lines

* Test funny column names
Name of columns are not unnecessarily alphanumeric words.
They need to be single or double quoted in formulas.
In a :cond lisp formula, only double quotes work.

** Quoted names

#+NAME: funnynames
  # some additional ignored directives
  # and blank lines

| first column | observed;number | computed/expected |
|--------------+-----------------+-------------------|
| a/experiment |             2.3 |               2.4 |
| a/experiment |            15.4 |              12.1 |
| a/experiment |             8.2 |               6.9 |
| b/test       |           -98.7 |               0.0 |
| b/test       |             4.5 |               3.4 |
| b/test       |             2.2 |               2.9 |
| zero         |               0 |                 0 |

#+BEGIN: aggregate :table "funnynames" :cols "\"first column\" mean('observed;number');%.3f mean('computed/expected');%.4f" :cond (and (>= (string-to-number "observed;number") 0) (not (equal "first column" "zero")))
| first column | mean(observed;number) | mean(computed/expected) |
|--------------+-----------------------+-------------------------|
| a/experiment |                 8.633 |                  7.1333 |
| b/test       |                 3.350 |                  3.1500 |
#+END:

#+BEGIN: aggregate :table "funnynames" :cols ("'first column'" "mean('observed;number');%.3f" "mean('computed/expected');%.4f") :cond "(and (>= (string-to-number \"observed;number\") 0) (not (equal \"first column\" \"zero\")))"
| first column | mean(observed;number) | mean(computed/expected) |
|--------------+-----------------------+-------------------------|
| a/experiment |                 8.633 |                  7.1333 |
| b/test       |                 3.350 |                  3.1500 |
#+END:

#+BEGIN: transpose :table "funnynames" :cols ("first column" "computed/expected" "observed;number")
| first column      |   | a/experiment | a/experiment | a/experiment | b/test | b/test | b/test | zero |
| computed/expected |   |          2.4 |         12.1 |          6.9 |    0.0 |    3.4 |    2.9 |    0 |
| observed;number   |   |          2.3 |         15.4 |          8.2 |  -98.7 |    4.5 |    2.2 |    0 |
#+END:

#+BEGIN: transpose :table "funnynames" :cols "'first column' 'computed/expected' 'observed;number'"
| first column      |   | a/experiment | a/experiment | a/experiment | b/test | b/test | b/test | zero |
| computed/expected |   |          2.4 |         12.1 |          6.9 |    0.0 |    3.4 |    2.9 |    0 |
| observed;number   |   |          2.3 |         15.4 |          8.2 |  -98.7 |    4.5 |    2.2 |    0 |
#+END:

** Non alphanumeric names
Accepted column names which do not require quoting:
- ascii letters
- numbers
- underscore _, dollar $, dot .
- accented letters like à é
- greek letters like α, Ω
- northen letters like ø
- russian letters like й
- esperanto letters like ŭ

#+NAME: non_alphanum
| _key.$ | v_A$4lé.à.α | on.eüΩ.øйŭ | 3.14 |
|--------+-------------+------------+------|
| a      |         2.2 |          1 |   10 |
| a      |         4.9 |          1 |   11 |
| b      |         7.7 |          1 |   12 |
| b      |         2.8 |          0 |   13 |
| b      |         9.3 |          0 |   14 |
| c      |         6.5 |          0 |   15 |
| a      |         8.4 |          0 |   16 |
| a      |         1.9 |          0 |   17 |
| b      |         5.6 |          0 |   18 |
| c      |         7.2 |          0 |   19 |

#+BEGIN: aggregate :table "non_alphanum" :cols "_key.$ vsum(v_A$4lé.à.α) vsum(on.eüΩ.øйŭ*10) vlist(on.eüΩ.øйŭ) vmean(3.14*1000)"
| _key.$ | vsum(v_A$4lé.à.α) | vsum(on.eüΩ.øйŭ*10) | vlist(on.eüΩ.øйŭ) | vmean(3.14*1000) |
|--------+-------------------+---------------------+-------------------+------------------|
| a      |              17.4 |                  20 | 1, 1, 0, 0        |            13500 |
| b      |              25.4 |                  10 | 1, 0, 0, 0        |            14250 |
| c      |              13.7 |                   0 | 0, 0              |            17000 |
#+END:

* Test malformed tables
Some columns are missing in some rows
This is on purpose
orgaggregate should tolerate such tables
Missing cells are handled as though they were empty

#+NAME: malformed
| Color | Level | Quantity | Day       |
|-------+-------+----------+-----------|
| Red   |    30 |       11 | Monday    |
| Blue  |    25 |        3 | Monday    |
|
| Red   |    45 |       15 | Tuesday   |
| Blue  |    33 |       18 | Tuesday   |
| Red   |    27 |
| Blue  |    12 |       16 | Wednesday |
| Blue  |    15 |       15 |
| Red   |    39 |       24 | Thursday  |
| Red   |    41 |       29 | Thursday  |
| Red   |    49 |       30 | Thursday  |
| Blue  |     7 |        5 | Friday    |
| Blue  |     6 |
| Blue  |    11 |        9 | Friday    |

#+BEGIN: aggregate :table "malformed" :cols "Day count() sum(Quantity)"
| Day       | count() | sum(Quantity) |
|-----------+---------+---------------|
| Monday    |       2 |            14 |
|           |       4 |            15 |
| Tuesday   |       2 |            33 |
| Wednesday |       1 |            16 |
| Thursday  |       3 |            83 |
| Friday    |       2 |            14 |
#+END:

#+BEGIN: aggregate :table "malformed" :cols "Color vlist(l10)" :precompute "Level*10;'l10'"
| Color | vlist(l10)                      |
|-------+---------------------------------|
| Red   | 300, 450, 270, 390, 410, 490    |
| Blue  | 250, 330, 120, 150, 70, 60, 110 |
|       |                                 |
#+END:

* Test vlist($) vs. ($)

#+name: suitableforlist
| Day       | Color      | Level |
|-----------+------------+-------|
| Monday    | Red        | 20*30 |
| Monday    | Blue       | 55+25 |
| Tuesday   | Red        |    51 |
| Tuesday   | Red        |    45 |
| Tuesday   | Blue       |    33 |
| Wednesday | Red        |    27 |
| Wednesday | Blue       |    12 |
| Wednesday | Green      |    15 |
| Thursday  | Red        |    39 |
| Thursday  | Red        |    41 |
| Thursday  | Red+Green  |    49 |
| Friday    | Blue       |   (7) |
| Friday    | Blue       | (6+1) |
| Friday    | Blue&Green |  [11] |

#+BEGIN: aggregate :table "suitableforlist" :cols "Day vlist(Color) (Color) vlist(Level) (Level) Level*100 Level^2"
| Day       | vlist(Color)           | (Color)                                 | vlist(Level)     | (Level)      | Level*100          | Level^2 |
|-----------+------------------------+-----------------------------------------+------------------+--------------+--------------------+---------|
| Monday    | Red, Blue              | [Red, Blue]                             | 20*30, 55+25     | [600, 80]    | [60000, 8000]      |  366400 |
| Tuesday   | Red, Red, Blue         | [Red, Red, Blue]                        | 51, 45, 33       | [51, 45, 33] | [5100, 4500, 3300] |    5715 |
| Wednesday | Red, Blue, Green       | [Red, Blue, Green]                      | 27, 12, 15       | [27, 12, 15] | [2700, 1200, 1500] |    1098 |
| Thursday  | Red, Red, Red+Green    | [Red, Red, Red + Green]                 | 39, 41, 49       | [39, 41, 49] | [3900, 4100, 4900] |    5603 |
| Friday    | Blue, Blue, Blue&Green | [Blue, Blue, error(4, '"Syntax error")] | (7), (6+1), [11] | [7, 7, [11]] | [700, 700, [1100]] |     219 |
#+END:

* Test sorting key alpha & numeric

#+NAME: unsortedtable
| p | q |    x | Day       | Color | Level | date                   |
|---+---+------+-----------+-------+-------+------------------------|
| 1 | b | 12.3 | Monday    | Red   |  2*30 | [2024-12-23 Mon 09:01] |
| 3 | b | 12.8 | Monday    | Blue  |  5+25 | [2019-11-24 Sun 13:04] |
| 1 | a |  3.5 | Tuesday   | Red   |    51 | [2029-09-25 Tue 13:54] |
| 2 | a |  3.9 | Tuesday   | Red   |    45 | [2033-09-26 Mon 03:55] |
| 3 | a |  3.5 | Tuesday   | Blue  |    33 | [2015-02-27 Fri 16:11] |
| 3 | a |  5.7 | Wednesday | Red   |    97 | [2001-01-19 Fri 03:49] |
| 1 | a |  5.1 | Wednesday | Blue  |    52 | [2035-12-26 Wed 00:00] |
|---+---+------+-----------+-------+-------+------------------------|
| 2 | b |  9.3 | Tuesday   | Red   |    39 | [2035-12-26 Wed 00:00] |
| 3 | b |  9.3 | Thursday  | Red   |    41 | [2002-01-19 Sat 23:22] |
| 4 | a |  1.4 | Friday    | Blue  |    79 | [2026-08-01 Sat 17:27] |
| 5 | a |  7.5 | Friday    | Blue  |   8+9 | [2020-09-15 Tue 13:07] |
| 4 | b |  8.2 | Thursday  | Red   |    41 | [2040-10-27 Sat 09:12] |
|---+---+------+-----------+-------+-------+------------------------|
| 5 | b |  1.1 | Wednesday | Red   |    62 | [2011-01-29 Sat 15:06] |

#+BEGIN: aggregate :table "unsortedtable" :cols "p;^n Day;^a"
| p | Day       |
|---+-----------|
| 1 | Monday    |
| 1 | Tuesday   |
| 1 | Wednesday |
| 2 | Tuesday   |
| 3 | Monday    |
| 3 | Thursday  |
| 3 | Tuesday   |
| 3 | Wednesday |
| 4 | Friday    |
| 4 | Thursday  |
| 5 | Friday    |
| 5 | Wednesday |
#+END:

* Test sorting numeric expression

#+BEGIN: aggregate :table "unsortedtable" :cols "Day count();^N"
| Day       | count() |
|-----------+---------|
| Tuesday   |       4 |
| Wednesday |       3 |
| Monday    |       2 |
| Thursday  |       2 |
| Friday    |       2 |
#+END:

#+BEGIN: aggregate :table "unsortedtable" :cols "Day vsum(Level);^n"
| Day       | vsum(Level) |
|-----------+-------------|
| Thursday  |          82 |
| Monday    |          90 |
| Friday    |          96 |
| Tuesday   |         168 |
| Wednesday |         211 |
#+END:

* Test sorting hline

#+BEGIN: aggregate :table "unsortedtable" :cols "hline;^N q;^a count()"
| hline | q | count() |
|-------+---+---------|
|     2 | b |       1 |
|     1 | a |       2 |
|     1 | b |       3 |
|     0 | a |       5 |
|     0 | b |       2 |
#+END:

* Test sorting dates-times

#+BEGIN: aggregate :table "unsortedtable" :cols "date;^T count()"
| date                   | count() |
|------------------------+---------|
| [2040-10-27 Sat 09:12] |       1 |
| [2035-12-26 Wed 00:00] |       2 |
| [2033-09-26 Mon 03:55] |       1 |
| [2029-09-25 Tue 13:54] |       1 |
| [2026-08-01 Sat 17:27] |       1 |
| [2024-12-23 Mon 09:01] |       1 |
| [2020-09-15 Tue 13:07] |       1 |
| [2019-11-24 Sun 13:04] |       1 |
| [2015-02-27 Fri 16:11] |       1 |
| [2011-01-29 Sat 15:06] |       1 |
| [2002-01-19 Sat 23:22] |       1 |
| [2001-01-19 Fri 03:49] |       1 |
#+END:

* Test sorting major-minor columns

#+BEGIN: aggregate :table "unsortedtable" :cols "date;^t3 Color;^a2 x;^n1"
| date                   | Color |    x |
|------------------------+-------+------|
| [2011-01-29 Sat 15:06] | Red   |  1.1 |
| [2026-08-01 Sat 17:27] | Blue  |  1.4 |
| [2015-02-27 Fri 16:11] | Blue  |  3.5 |
| [2029-09-25 Tue 13:54] | Red   |  3.5 |
| [2033-09-26 Mon 03:55] | Red   |  3.9 |
| [2035-12-26 Wed 00:00] | Blue  |  5.1 |
| [2001-01-19 Fri 03:49] | Red   |  5.7 |
| [2020-09-15 Tue 13:07] | Blue  |  7.5 |
| [2040-10-27 Sat 09:12] | Red   |  8.2 |
| [2002-01-19 Sat 23:22] | Red   |  9.3 |
| [2035-12-26 Wed 00:00] | Red   |  9.3 |
| [2024-12-23 Mon 09:01] | Red   | 12.3 |
| [2019-11-24 Sun 13:04] | Blue  | 12.8 |
#+END:

* Test sorting push

#+ORGTBL: SEND sortag1 orgtbl-to-aggregated-table :cols "cölØr vsum(vâluε);^N count();^N vmean('ra;han');f3"
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
| Red    |   1.1 |     58 |

#+BEGIN RECEIVE ORGTBL sortag1
| cölØr  | vsum(vâluε) | count() | vmean(ra;han) |
|--------+-------------+---------+---------------|
| Yellow |        23.5 |       4 |        50.250 |
| Blue   |        20.6 |       3 |        48.333 |
| Red    |        12.4 |       5 |        53.800 |
#+END RECEIVE ORGTBL sortag1

* Test hline output

#+name: withhline
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
|--------+-------+--------|
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
|--------+-------+--------|
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
|--------+-------+--------|
| Red    |   1.1 |     58 |
| Yellow |   3.4 |     51 |

Are original hlines given back?
#+BEGIN: aggregate :table "withhline" :cols "cölØr vâluε 'ra;han'" :hline 1
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
|--------+-------+--------|
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
|--------+-------+--------|
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
|--------+-------+--------|
| Red    |   1.1 |     58 |
| Yellow |   3.4 |     51 |
#+END:

I do not specify hlines in the output
#+BEGIN: aggregate :table "withhline" :cols "cölØr vâluε 'ra;han'"
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
| Red    |   1.1 |     58 |
| Yellow |   3.4 |     51 |
#+END:

What if I want hline on cölØr?
#+BEGIN: aggregate :table "withhline" :cols "cölØr;^a vâluε 'ra;han'" :hline 1
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Blue   |   4.9 |     64 |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Red    |   2.6 |     84 |
| Red    |   3.9 |     51 |
| Red    |   1.1 |     58 |
|--------+-------+--------|
| Yellow |   9.1 |     95 |
| Yellow |   5.4 |     17 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
| Yellow |   3.4 |     51 |
#+END:

And if I explicitly require hline column?
#+BEGIN: aggregate :table "withhline" :cols "hline;^n cölØr;^a vâluε 'ra;han'"
| hline | cölØr  | vâluε | ra;han |
|-------+--------+-------+--------|
|     0 | Red    |   1.3 |     41 |
|     0 | Red    |   3.5 |     35 |
|     0 | Red    |   2.6 |     84 |
|     0 | Yellow |   9.1 |     95 |
|     1 | Blue   |   8.7 |     52 |
|     1 | Blue   |   7.0 |     29 |
|     1 | Yellow |   5.4 |     17 |
|     2 | Blue   |   4.9 |     64 |
|     2 | Red    |   3.9 |     51 |
|     2 | Yellow |   2.4 |     55 |
|     2 | Yellow |   6.6 |     34 |
|     3 | Red    |   1.1 |     58 |
|     3 | Yellow |   3.4 |     51 |
#+END:

And hline rows as well as column?
#+BEGIN: aggregate :table "withhline" :cols "hline;^N cölØr;^a vâluε 'ra;han'" :hline 1
| hline | cölØr  | vâluε | ra;han |
|-------+--------+-------+--------|
|     3 | Red    |   1.1 |     58 |
|     3 | Yellow |   3.4 |     51 |
|-------+--------+-------+--------|
|     2 | Blue   |   4.9 |     64 |
|     2 | Red    |   3.9 |     51 |
|     2 | Yellow |   2.4 |     55 |
|     2 | Yellow |   6.6 |     34 |
|-------+--------+-------+--------|
|     1 | Blue   |   8.7 |     52 |
|     1 | Blue   |   7.0 |     29 |
|     1 | Yellow |   5.4 |     17 |
|-------+--------+-------+--------|
|     0 | Red    |   1.3 |     41 |
|     0 | Red    |   3.5 |     35 |
|     0 | Red    |   2.6 |     84 |
|     0 | Yellow |   9.1 |     95 |
#+END:

Same with hline & cölØr to separate blocks
#+BEGIN: aggregate :table "withhline" :cols "hline;^N cölØr;^a vâluε 'ra;han'" :hline 2
| hline | cölØr  | vâluε | ra;han |
|-------+--------+-------+--------|
|     3 | Red    |   1.1 |     58 |
|-------+--------+-------+--------|
|     3 | Yellow |   3.4 |     51 |
|-------+--------+-------+--------|
|     2 | Blue   |   4.9 |     64 |
|-------+--------+-------+--------|
|     2 | Red    |   3.9 |     51 |
|-------+--------+-------+--------|
|     2 | Yellow |   2.4 |     55 |
|     2 | Yellow |   6.6 |     34 |
|-------+--------+-------+--------|
|     1 | Blue   |   8.7 |     52 |
|     1 | Blue   |   7.0 |     29 |
|-------+--------+-------+--------|
|     1 | Yellow |   5.4 |     17 |
|-------+--------+-------+--------|
|     0 | Red    |   1.3 |     41 |
|     0 | Red    |   3.5 |     35 |
|     0 | Red    |   2.6 |     84 |
|-------+--------+-------+--------|
|     0 | Yellow |   9.1 |     95 |
#+END:

* Test filter only
#+name: planet
| planet  |   mass kg | dist MKM |
|---------+-----------+----------|
| Sun     | 1.9891e30 |        0 |
| Mercury | 3.3022e23 |       60 |
| Venus   | 4.8685e24 |      100 |
| Earth   | 5.9736e24 |      150 |
| Mars    | 6.4185e23 |      220 |
| Jupiter | 1.8986e27 |      780 |
| Saturn  | 5.6846e26 |     1420 |
| Uranus  | 8.6810e25 |     2870 |
| Neptune | 10.243e25 |     4500 |
| Pluto   |   1.25e22 |     5800 |

Without :cols parameter, we get all columns

#+BEGIN: aggregate :table "planet" :cond (> (string-to-number "dist MKM") 150)
| planet  |   mass kg | dist MKM |
|---------+-----------+----------|
| Mars    | 6.4185e23 |      220 |
| Jupiter | 1.8986e27 |      780 |
| Saturn  | 5.6846e26 |     1420 |
| Uranus  | 8.6810e25 |     2870 |
| Neptune | 10.243e25 |     4500 |
| Pluto   |   1.25e22 |     5800 |
#+END:

What happens without column names in the input?

#+name: planetnh
| Sun     | 1.9891e30 |        0 |
| Mercury | 3.3022e23 |       60 |
| Venus   | 4.8685e24 |      100 |
| Earth   | 5.9736e24 |      150 |
| Mars    | 6.4185e23 |      220 |
| Jupiter | 1.8986e27 |      780 |
| Saturn  | 5.6846e26 |     1420 |
| Uranus  | 8.6810e25 |     2870 |
| Neptune | 10.243e25 |     4500 |
| Pluto   |   1.25e22 |     5800 |

#+BEGIN: aggregate :table "planetnh" :cond (<= (string-to-number "$3") 150)
| $1      |        $2 |  $3 |
|---------+-----------+-----|
| Sun     | 1.9891e30 |   0 |
| Mercury | 3.3022e23 |  60 |
| Venus   | 4.8685e24 | 100 |
| Earth   | 5.9736e24 | 150 |
#+END:

* Test custom column names

#+BEGIN: aggregate :table "pulledtable" :cols "pé;^n vsum(xà);'sum_of_xà' vmean(yÿ);'average Ÿ' vmax(zö);'MAX of ZÖ'"
| pé | sum_of_xà |     average Ÿ | MAX of ZÖ |
|----+-----------+---------------+-----------|
|  1 |      20.1 |             4 |         9 |
|  2 |        12 |             5 |         5 |
|  3 |        29 |           5.5 |         9 |
|  4 |     a + b | a / 2 + b / 2 |         8 |
|  5 | a + b + 3 | 5 a + b^2 / 2 |         8 |
#+END:

* Test no collision
There should be no collision between column names and reserved Calc function names.
For instance ~vsum~, which is a Calc function, should be usable as a column name.

#+name: keyword-collision
| vmean | sort | vsum | sum | vmax | aaa |
|-------+------+------+-----+------+-----|
|     2 | 12.3 |   43 |  43 |    1 | 8.2 |
|     8 | 34.4 |   81 |  81 |    1 | 9.3 |
|     4 | 51.5 |   40 |  40 |    1 | 1.3 |
|     5 |  8.1 |   27 |  27 |    2 | 3.9 |
|     2 |  4.7 |   41 |  41 |    2 | 3.5 |
|     9 | 33.9 |   62 |  62 |    3 | 2.1 |
|     1 | 41.7 |   83 |  83 |    3 | 2.7 |

#+BEGIN: aggregate :table "keyword-collision" :cols "vmax count() vsum(vmean) vsum(sort) sort(vsum) sort(sum) vmean(sum);%.2f vmean(vsum);f2"
| vmax | count() | vsum(vmean) | vsum(sort) | sort(vsum)   | sort(sum)    | vmean(sum) | vmean(vsum) |
|------+---------+-------------+------------+--------------+--------------+------------+-------------|
|    1 |       3 |          14 |       98.2 | [40, 43, 81] | [40, 43, 81] |      54.67 |       54.67 |
|    2 |       2 |           7 |       12.8 | [27, 41]     | [27, 41]     |      34.00 |          34 |
|    3 |       2 |          10 |       75.6 | [62, 83]     | [62, 83]     |      72.50 |       72.50 |
#+END:

* Test disordered formatters & decorators

#+BEGIN: aggregate :table "planet" :cols "planet vmax('mass kg');^n;e4;'MassKG' vmin('dist MKM')*1e6;^N;'DistKM';e2"
| planet  |   MassKG | DistKM |
|---------+----------+--------|
| Pluto   |  12.5e21 |  5.8e9 |
| Mercury | 330.2e21 |   60e6 |
| Mars    | 641.9e21 |  220e6 |
| Venus   | 4.869e24 |  100e6 |
| Earth   | 5.974e24 |  150e6 |
| Uranus  | 86.81e24 |  2.9e9 |
| Neptune | 102.4e24 |  4.5e9 |
| Saturn  | 568.5e24 |  1.4e9 |
| Jupiter | 1.899e27 |  780e6 |
| Sun     | 1.989e30 |    0e0 |
#+END:

* Test lambda post-processing

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post (lambda (table) (append table '(hline (c 112233))))
| qû | vsum(zö) |
|----+----------|
| b  |       38 |
| a  |       29 |
|----+----------|
| c  |   112233 |
#+END:

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post (lambda (table) (append '((c 112233) hline) table))
| c  |   112233 |
|----+----------|
| qû | vsum(zö) |
|----+----------|
| b  |       38 |
| a  |       29 |
#+END:

* Test babel post-processing

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post "post-proc-babel(*this*)"
| AA |     BB |
|----+--------|
| c  | 112233 |
|----+--------|
| b  |     38 |
| a  |     29 |
#+END:

#+name: post-proc-babel
#+begin_src elisp :var intbl="" :colnames '(AA BB)
(append
 '((c 112233) hline)
 intbl))
#+end_src

* Test push lambda post-processing

#+ORGTBL: SEND sent-aggregate-post orgtbl-to-aggregated-table :cols "a vsum(b) vsum(c)" :post (lambda (tbl) (append tbl '(hline (h 9 "8"))))
#+ORGTBL: SEND sent-transpose-post orgtbl-to-transposed-table :cols "a c"               :post (lambda (tbl) (append tbl '(hline (h "" 3.4 "8.8"))))
| a |  b |  c |
|---+----+----|
| x | 34 | 56 |
| i | 90 | 12 |
| x | 51 |  3 |
| i |  1 | 11 |

#+BEGIN RECEIVE ORGTBL sent-aggregate-post
| a | vsum(b) | vsum(c) |
|---+---------+---------|
| x |      85 |      59 |
| i |      91 |      23 |
|---+---------+---------|
| h |       9 |       8 |
#+END RECEIVE ORGTBL sent-aggregate-post

#+BEGIN RECEIVE ORGTBL sent-transpose-post
| a |   |   x |   i | x |  i |
| c |   |  56 |  12 | 3 | 11 |
|---+---+-----+-----+---+----|
| h |   | 3.4 | 8.8 |
#+END RECEIVE ORGTBL sent-transpose-post

* Test push babel post-processing

#+ORGTBL: SEND sent-transpose-post-babel orgtbl-to-transposed-table :cols "p r q"             :post "post-proc-babel-send(*this*)"
#+ORGTBL: SEND sent-aggregate-post-babel orgtbl-to-aggregated-table :cols "p vsum(q) vsum(r)" :post "post-proc-babel-send(intbl=*this*)"
|     q | p |     r |
|-------+---+-------|
|  34.9 | x |  56.1 |
|  9.20 | i |  77.2 |
| 51.29 | x |  3.86 |
|  76.7 | i | 19.47 |

#+BEGIN RECEIVE ORGTBL sent-aggregate-post-babel
| x   |  86.19 | 59.96 |
| i   |   85.9 | 96.67 |
| add | 3.1416 |   5.6 |
|-----+--------+-------|
| sub |  2.718 | -42.0 |
#+END RECEIVE ORGTBL sent-aggregate-post-babel

#+BEGIN RECEIVE ORGTBL sent-transpose-post-babel
| p   |        |     x |    i |     x |     i |
| r   |        |  56.1 | 77.2 |  3.86 | 19.47 |
| q   |        |  34.9 | 9.20 | 51.29 |  76.7 |
| add | 3.1416 |   5.6 |
|-----+--------+-------+------+-------+-------|
| sub |  2.718 | -42.0 |
#+END RECEIVE ORGTBL sent-transpose-post-babel

#+name: post-proc-babel-send
#+begin_src elisp :var intbl=""
(append
 intbl
 '((add 3.1416 "5.6") hline (sub 2.718 "-42.0")))
#+end_src

* Japanese characters
Japanese characters are wider than ASCII ones.
In mono-spaced fonts, they are often 2 times wider.

Not all fonts are equal. The Ubuntu one is not too bad, although not perfect:
: (set-face-font 'default "Ubuntu Mono")

#+name: 日本のテーブル
| 如何         | 量 |
|--------------+----|
| 急行電車     | 23 |
| 山に雪が降る | 21 |
| 鳥と花       | 34 |
| 急行電車     | 61 |
| 鳥と花       | 93 |
| 山に雪が降る | 48 |

#+BEGIN: aggregate :table "日本のテーブル" :cols "如何 vsum(量)"
| 如何         | vsum(量) |
|--------------+----------|
| 急行電車     |       84 |
| 山に雪が降る |       69 |
| 鳥と花       |      127 |
#+END:

* Alignment cookies
What to do with cookies?
<> <l> <c> <r> <12> <l12> <c12> <r12>

They are not real data, rather metadata. Mixed into data, they may
result in false aggregations. Therefore they should be ignored.

But in the header of tables, cookies do not change aggregated
results. They format the source column. Probably the aggregated column
may benefit from the same formatting. Therefore, cookies are kept in
headers.

#+name: with-cookies
| color  | quantity |  level |
| <l>    |     <r7> |    <3> |
| kolor  |     kiom | nivelo |
|--------+----------+--------|
| yellow |       72 |      3 |
| green  |       55 |      0 |
| <c>    |          |      4 |
| orange |       80 |      0 |
| white  |       19 |      6 |
| green  |        4 |      4 |
| yellow |       58 |      5 |
|        |     <25> |      0 |
| orange |       22 |      4 |
| orange |        7 |      4 |
| <>     |       <> |      2 |
| red    |       71 |      3 |
| blue   |       56 |      3 |
| red    |       52 |      5 |
| <7>    |          |      3 |
| orange |       35 |      0 |
|        |      <r> |      3 |
| yellow |       23 |      0 |
| <l>    |     <44> |      0 |
| blue   |       93 |      4 |
| black  |      <l> |      0 |
| green  |       82 |      2 |
| <9>    |      <4> |      5 |

#+BEGIN: aggregate :table "with-cookies" :cols "color vsum(quantity);'sum' count();'nb' vsum(quantity)/vmean(level);'leveled'"
| color  |  sum | nb |       leveled |
| <l>    | <r7> |    |               |
| kolor  | kiom |    |               |
|--------+------+----+---------------|
| yellow |  153 |  3 | 57.3749999999 |
| green  |  141 |  3 |          70.5 |
| orange |  144 |  4 |            72 |
| white  |   19 |  1 | 3.16666666667 |
| red    |  123 |  2 |         30.75 |
| blue   |  149 |  2 | 42.5714285714 |
#+END:

#+BEGIN: transpose :table "with-cookies"
| color    | <l>  | kolor  |   | yellow | green | orange | white | green | yellow | orange | orange | red | blue | red | orange | yellow | blue | green |
| quantity | <r7> | kiom   |   |     72 |    55 |     80 |    19 |     4 |     58 |     22 |      7 |  71 |   56 |  52 |     35 |     23 |   93 |    82 |
| level    | <3>  | nivelo |   |      3 |     0 |      0 |     6 |     4 |      5 |      4 |      4 |   3 |    3 |   5 |      0 |      0 |    4 |     2 |
#+END:

* 1st data row is not the header
When the input table does not have a header,
the first data row should not be mistaken with a header.

#+name: missing-header
| a | 12 | 33 |
| c | 13 | 12 |
| x | 14 | 12 |
| y | 15 | 45 |
| z |  7 |  7 |

#+BEGIN: aggregate :table "missing-header" :cols "$1" :cond (equal $3 "12")
| $1 |
|----|
| c  |
| x  |
#+END:

In case of a mistake, the result is:
| $1 |
|----|
| z  |

* Debug settings

4 settings: c q C Q

#+BEGIN: aggregate :table "withhline" :cols "hline vsum(vâluε);c vsum(vâluε);q vsum(vâluε);C vsum(vâluε);Q"
| hline | vsum(vâluε) | vsum(vâluε)                       | vsum(vâluε)                | vsum(vâluε)                                                                   |
|-------+-------------+-----------------------------------+----------------------------+-------------------------------------------------------------------------------|
|     0 | vsum($2)    | (calcFunc-vsum (calcFunc-Frux 2)) | vsum([1.3, 3.5, 9.1, 2.6]) | (calcFunc-vsum (vec (float 13 -1) (float 35 -1) (float 91 -1) (float 26 -1))) |
|     1 | vsum($2)    | (calcFunc-vsum (calcFunc-Frux 2)) | vsum([8.7, 7., 5.4])       | (calcFunc-vsum (vec (float 87 -1) (float 7 0) (float 54 -1)))                 |
|     2 | vsum($2)    | (calcFunc-vsum (calcFunc-Frux 2)) | vsum([4.9, 3.9, 2.4, 6.6]) | (calcFunc-vsum (vec (float 49 -1) (float 39 -1) (float 24 -1) (float 66 -1))) |
|     3 | vsum($2)    | (calcFunc-vsum (calcFunc-Frux 2)) | vsum([1.1, 3.4])           | (calcFunc-vsum (vec (float 11 -1) (float 34 -1)))                             |
#+END:

* hline as a column to be aggregated
Does it make sense to calculate something based on hline?
Anyway, it is now available at no cost.

#+BEGIN: aggregate :table "withhline" :cols "cölØr vmean(hline*15) vlist(hline)"
| cölØr  | vmean(hline*15) | vlist(hline)  |
|--------+-----------------+---------------|
| Red    |              15 | 0, 0, 0, 2, 3 |
| Yellow |              24 | 0, 1, 2, 2, 3 |
| Blue   |              20 | 1, 1, 2       |
#+END:

We see that Reds are more at the begining of the input table,
while Yellows are more at the end.

* Input table is a Babel script

Note the =:colnames yes= parameter to output a header with label & value
column names.

The table resulting from the =ascript= script is computed on the fly, it
appears nowhere in the buffer.

#+name: ascript
#+begin_src elisp :colnames yes
`(
  (label "value")                       ; cells are symbols or strings
  hline
  ,@(cl-loop
     for i from 1 to 20
     collect
     (list
      (format "%c" (+ ?a (% i 3)))      ; cell is a string
      i)))                              ; cell is a number
#+end_src

Use column names in the =:cols= specification:

#+BEGIN: aggregate :table "ascript" :cols "label vsum(value)"
| label | vsum(value) |
|-------+-------------|
| b     |          70 |
| c     |          77 |
| a     |          63 |
#+END:

Use dollar to specify columns in =:cols=:

#+BEGIN: aggregate :table "ascript" :cols "$1 vsum($2)"
| $1 | vsum($2) |
|----+----------|
| b  |       70 |
| c  |       77 |
| a  |       63 |
#+END:

a script with a parameter:

#+name: ascriptparam
#+begin_src elisp :colnames yes :var len=20
`(
  ("label" value)                       ; cells are symbols or strings
  hline
  ,@(cl-loop
     for i from 1 to len
     collect
     (list
      (format "%c" (+ ?a (% i 3)))      ; cell is a string
      i)))                              ; cell is a number
#+end_src

#+BEGIN: aggregate :table "ascriptparam(len=10)" :cols "label vsum(value)"
| label | vsum(value) |
|-------+-------------|
| b     |          22 |
| c     |          15 |
| a     |          18 |
#+END:

a longer table is generated (100 rows),
but only 10 rows are retained (12 = 10 rows + header + hline)

#+BEGIN: aggregate :table "ascriptparam(len=100)[0:12]" :cols "label vsum(value)"
| label | vsum(value) |
|-------+-------------|
| b     |          22 |
| c     |          26 |
| a     |          18 |
#+END:

* Column & single-cell formulas
Is the Org Mode bug overcome?

It happens when
- there are both a column formula and a single cell formula
- they need to add new columns

#+BEGIN: aggregate :table "planet" :cols "planet vsum('dist MKM');'km'"
| planet  |   km |    au |
|---------+------+-------|
| Sun     |    0 |  0.00 |
| Mercury |   60 |  0.40 |
| Venus   |  100 |  0.67 |
| Earth   |  150 |  1.00 |
| Mars    |  220 |  1.47 |
| Jupiter |  780 |  5.20 |
| Saturn  | 1420 |  9.47 |
| Uranus  | 2870 | 19.13 |
| Neptune | 4500 | 30.00 |
| Pluto   | 5800 | 38.67 |
#+TBLFM: $3=$2/150;%.2f::@1$3=au
#+END:

* Aggregate on computed bins
Sometimes, input columns are not enough to aggregate on.
Virtual computed columns may be handy.

#+name: want-month
| Date             | Quty |
|------------------+------|
| [2027-02-10 mer] |   38 |
| [2027-02-21 dim] |   58 |
| [2027-03-04 ĵaŭ] |   52 |
| [2027-03-15 lun] |   35 |
| [2027-03-26 ven] |   62 |
| [2027-04-06 mar] |   19 |
| [2027-04-17 sab] |   22 |
| [2027-04-28 mer] |   63 |
| [2027-05-09 dim] |   70 |
| [2027-05-20 ĵaŭ] |   51 |
| [2027-05-31 lun] |   55 |
| [2027-06-11 ven] |   49 |
| [2027-06-22 mar] |   96 |
| [2027-07-03 sab] |   62 |
| [2027-07-14 mer] |    7 |
| [2027-07-25 dim] |   43 |

Aggregate on months extracted from 'Date':

#+BEGIN: aggregate :table "want-month" :cols "Month vsum(Quty)" :precompute ("month(Date);'Month'")
| Month | vsum(Quty) |
|-------+------------|
|     2 |         96 |
|     3 |        149 |
|     4 |        104 |
|     5 |        176 |
|     6 |        145 |
|     7 |        112 |
#+END:

An input table with the first column acting as a tag, and the second as a quantity:

#+name: want-bins
| 129 | 32.56 |
| 133 | 71.45 |
| 139 | 72.80 |
| 172 | 14.99 |
| 343 | 88.58 |
| 373 | 51.56 |
| 406 | 87.66 |
| 444 | 14.13 |
| 459 | 52.87 |
| 510 | 59.10 |
| 527 | 78.41 |
| 634 | 23.71 |
| 673 | 91.14 |
| 739 | 83.03 |
| 750 | 28.13 |
| 757 | 60.63 |
| 792 | 64.62 |
| 833 | 13.28 |
| 848 | 29.89 |
| 871 | 82.70 |
| 945 | 22.95 |
| 967 | 42.58 |

We want to aggregate on coarse bins made of hundredths of the firt column:

#+BEGIN: aggregate :table "want-bins" :cols "$3 vmean($2);f2" :precompute ("'(floor (/ (string-to-number $1) 100))")
| $3 | vmean($2) |
|----+-----------|
|  1 |     47.95 |
|  3 |     70.07 |
|  4 |     51.55 |
|  5 |     68.76 |
|  6 |     57.43 |
|  7 |     59.10 |
|  8 |     41.96 |
|  9 |     32.77 |
#+END:

Same aggregation, with additional metrics (min & max):

#+BEGIN: aggregate :table "want-bins" :cols "$3 vmin(H) vmax(H) vmean($2);f2" :precompute "'(floor (/ (string-to-number $1) 100)) :: $1/100;'H'"
| $3 | vmin(H) | vmax(H) | vmean($2) |
|----+---------+---------+-----------|
|  1 |    1.29 |    1.72 |     47.95 |
|  3 |    3.43 |    3.73 |     70.07 |
|  4 |    4.06 |    4.59 |     51.55 |
|  5 |     5.1 |    5.27 |     68.76 |
|  6 |    6.34 |    6.73 |     57.43 |
|  7 |    7.39 |    7.92 |     59.10 |
|  8 |    8.33 |    8.71 |     41.96 |
|  9 |    9.45 |    9.67 |     32.77 |
#+END:

Let us format a pre-computed column:

#+BEGIN: aggregate :table "want-bins" :cols "LL list(H)" :precompute "'(floor (/ (string-to-number $1) 100));%.3f;'LL' :: $1/100;'H';%.1f"
|    LL | list(H)            |
|-------+--------------------|
| 1.000 | 1.3, 1.3, 1.4, 1.7 |
| 3.000 | 3.4, 3.7           |
| 4.000 | 4.1, 4.4, 4.6      |
| 5.000 | 5.1, 5.3           |
| 6.000 | 6.3, 6.7           |
| 7.000 | 7.4, 7.5, 7.6, 7.9 |
| 8.000 | 8.3, 8.5, 8.7      |
| 9.000 | 9.4, 9.7           |
#+END:

* Distant tables

table by name

#+BEGIN: aggregate :table "distant-tests.org:distanttable" :cols "tag vsum(val)"
| tag | vsum(val) |
|-----+-----------|
| A   |    405.43 |
| BB  |    453.63 |
| CCC |    215.71 |
#+END:

Babel by name

#+BEGIN: aggregate :table "distant-tests.org:distantbabel" :cols "tag vsum(value)"
| tag | vsum(value) |
|-----+-------------|
| BB  |         825 |
| CCC |         818 |
| A   |         832 |
#+END:

Babel by name and parameter

#+BEGIN: aggregate :table "distant-tests.org:distantbabel(factor=17)" :cols "tag vsum(value)"
| tag | vsum(value) |
|-----+-------------|
| BB  |         825 |
| CCC |        1114 |
| A   |         536 |
#+END:

Babel, mean of floating points

#+BEGIN: aggregate :table "distant-tests.org:distantbabel(factor=17)" :cols "tag vmean(inv) count()"
| tag |     vmean(inv) | count() |
|-----+----------------+---------|
| BB  | 0.976763739953 |      17 |
| CCC | 0.975810407486 |      17 |
| A   | 0.976263808395 |      16 |
#+END:

table by ID

#+BEGIN: aggregate :table "55ab27a2-c44b-4a14-9ba4-f6879375207d[0:7]" :cols "ref vsum(val)"
| ref  | vsum(val) |
|------+-----------|
| S    |     685.6 |
| TT   |     996.4 |
| UUU  |     945.2 |
| VVVV |     974.7 |
#+END:

* CSV table

abundance of large cities per country
the source CSV file is TAB-separated, which is guessed

#+BEGIN: aggregate :table "geography-a.csv:(csv)" :cols "$2 count();^N vsum($3)"
| $2             | count() |  vsum($3) |
|----------------+---------+-----------|
| China          |      28 | 264183191 |
| India          |      10 | 140092165 |
| Japan          |       4 |  71117892 |
| Brazil         |       4 |  48284586 |
| Mexico         |       3 |  33697146 |
| Bangladesh     |       2 |  30197563 |
| Egypt          |       2 |  28897566 |
| Pakistan       |       2 |  32895483 |
| Nigeria        |       2 |  21763797 |
| Turkey         |       2 |  21777496 |
| Russia         |       2 |  18346030 |
| Vietnam        |       2 |  15392473 |
| Saudi Arabia   |       2 |  12980333 |
| Spain          |       2 |  12577695 |
| South Africa   |       2 |  11501203 |
| Australia      |       2 |  10663074 |
| DR Congo       |       1 |  17815364 |
| Argentina      |       1 |  15714124 |
| Philippines    |       1 |  15211511 |
| Colombia       |       1 |  11779275 |
| Indonesia      |       1 |  11628728 |
| Peru           |       1 |  11529982 |
| Thailand       |       1 |  11415533 |
| France         |       1 |  11352823 |
| Angola         |       1 |  10049628 |
| South Korea    |       1 |  10059272 |
| United Kingdom |       1 |   9818142 |
| Iran           |       1 |   9738111 |
| Malaysia       |       1 |   8980578 |
| Tanzania       |       1 |   8529744 |
| Iraq           |       1 |   8154140 |
| United States  |       1 |   7966324 |
| Hong Kong      |       1 |   7791531 |
| Chile          |       1 |   6973392 |
| Sudan          |       1 |   6778168 |
| Canada         |       1 |   6513813 |
| Singapore      |       1 |   6167759 |
| Ivory Coast    |       1 |   6054358 |
| Ethiopia       |       1 |   5961711 |
| Myanmar        |       1 |   5829964 |
| Kenya          |       1 |   5772121 |
| Afghanistan    |       1 |   4862586 |
| Cameroon       |       1 |   4859198 |
| Israel         |       1 |   4577871 |
| Taiwan         |       1 |   4570576 |
#+END:

A CVS table oddly formatted, with a header:

#+BEGIN: aggregate :table "hline.csv:(csv header)" :cols "cc vsum(bb) vmean(aa)"
| cc    | vsum(bb) | vmean(aa) |
|-------+----------+-----------|
| apple |      831 |      62.2 |
| grape |      -22 |     13.75 |
#+END:

Here we add an external header, even though there is already a header
in the CSV file, and see what happens:

#+BEGIN: aggregate :table "hline.csv:(csv colnames (level quantity fruit))" :cols "fruit vsum(quantity)"
| fruit | vsum(quantity) |
|-------+----------------|
| cc    |             bb |
| apple |            831 |
| grape |            -22 |
#+END:

Check if horizontal separators are recognized:

#+BEGIN: aggregate :table "hline.csv:(csv header)" :cols "hline cc vsum(bb)" :hline 1
| hline | cc    | vsum(bb) |
|-------+-------+----------|
|     0 | apple |      654 |
|     0 | grape |      -78 |
|-------+-------+----------|
|     1 | grape |       45 |
|     1 | apple |      192 |
|-------+-------+----------|
|     2 | apple |      -15 |
|     2 | grape |       11 |
#+END:

CSV in distant Org file

#+BEGIN: aggregate :table "distant-tests.org:distantcsv(csv header)" :cols "label vsum(quantity)"
| label | vsum(quantity) |
|-------+----------------|
| jes   |             70 |
| ne    |           -106 |
#+END:

* JSON table

same as in CSV

#+BEGIN: aggregate :table "geography-a.json:(json)" :cols "$2 count();^N vsum($3)"
| $2             | count() |  vsum($3) |
|----------------+---------+-----------|
| China          |      28 | 264183191 |
| India          |      10 | 140092165 |
| Japan          |       4 |  71117892 |
| Brazil         |       4 |  48284586 |
| Mexico         |       3 |  33697146 |
| Bangladesh     |       2 |  30197563 |
| Egypt          |       2 |  28897566 |
| Pakistan       |       2 |  32895483 |
| Nigeria        |       2 |  21763797 |
| Turkey         |       2 |  21777496 |
| Russia         |       2 |  18346030 |
| Vietnam        |       2 |  15392473 |
| Saudi Arabia   |       2 |  12980333 |
| Spain          |       2 |  12577695 |
| South Africa   |       2 |  11501203 |
| Australia      |       2 |  10663074 |
| DR Congo       |       1 |  17815364 |
| Argentina      |       1 |  15714124 |
| Philippines    |       1 |  15211511 |
| Colombia       |       1 |  11779275 |
| Indonesia      |       1 |  11628728 |
| Peru           |       1 |  11529982 |
| Thailand       |       1 |  11415533 |
| France         |       1 |  11352823 |
| Angola         |       1 |  10049628 |
| South Korea    |       1 |  10059272 |
| United Kingdom |       1 |   9818142 |
| Iran           |       1 |   9738111 |
| Malaysia       |       1 |   8980578 |
| Tanzania       |       1 |   8529744 |
| Iraq           |       1 |   8154140 |
| United States  |       1 |   7966324 |
| Hong Kong      |       1 |   7791531 |
| Chile          |       1 |   6973392 |
| Sudan          |       1 |   6778168 |
| Canada         |       1 |   6513813 |
| Singapore      |       1 |   6167759 |
| Ivory Coast    |       1 |   6054358 |
| Ethiopia       |       1 |   5961711 |
| Myanmar        |       1 |   5829964 |
| Kenya          |       1 |   5772121 |
| Afghanistan    |       1 |   4862586 |
| Cameroon       |       1 |   4859198 |
| Israel         |       1 |   4577871 |
| Taiwan         |       1 |   4570576 |
#+END:

Same as CSV, vector of vectors, first vector is the header

#+BEGIN: aggregate :table "hline-header.json:(json header)" :cols "cc vsum(bb) vmean(aa)"
| cc    | vsum(bb) | vmean(aa) |
|-------+----------+-----------|
| apple |      831 |      62.2 |
| grape |      -22 |     13.75 |
#+END:

Same test, input is mixed vectors and hashed-objects,
resulting header is a mixture of first vector and keys of hashed-objects.

#+BEGIN: aggregate :table "hline-hash.json:(json header)" :cols "cc vsum(bb) vmean(aa)"
| cc    | vsum(bb) | vmean(aa) |
|-------+----------+-----------|
| apple |      831 |      62.2 |
| grape |      -22 |     13.75 |
#+END:

Understand input hline

#+BEGIN: aggregate :table "hline-hash.json:(json)" :cols "hline bb" :hline "1"
| hline |  bb |
|-------+-----|
|     0 | 654 |
|     0 | -78 |
|-------+-----|
|     1 | +45 |
|     1 | +35 |
|     1 | +66 |
|     1 | +91 |
|-------+-----|
|     2 | -15 |
|     2 |   7 |
|     2 |   4 |
#+END:

JSON in distant Org file

#+BEGIN: aggregate :table "distant-tests.org:distantjson(json)" :cols "$2 vsum($1)"
| $2   | vsum($1) |
|------+----------|
| univ |       42 |
| jes  |      555 |
| ne   |     -176 |
#+END:
